#pragma once

#include <windows.h>

#include "module_scanner.h"
#include "../utils/threads_util.h"

namespace pesieve {

	//!  A report from the thread scan, generated by ThreadScanner
	class ThreadScanReport : public ModuleScanReport
	{
	public:
		ThreadScanReport(DWORD _tid)
			: ModuleScanReport(0, 0), 
			tid(_tid), thread_ip(0), thread_return(0), protection(0), page_state(0)
		{
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			ModuleScanReport::_toJSON(outs, level);
			outs << ",\n";

			OUT_PADDED(outs, level, "\"thread_id\" : ");
			outs << std::dec << tid;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"thread_ip\" : ");
			outs << "\"" << std::hex << thread_ip << "\"";
			outs << ",\n";
			if (thread_return) {
				OUT_PADDED(outs, level, "\"thread_return\" : ");
				outs << "\"" << std::hex << thread_return << "\"";
				outs << ",\n";
			}

			OUT_PADDED(outs, level, "\"page_state\" : ");
			outs << "\"" << std::hex << page_state << "\"";
			outs << ",\n";

			OUT_PADDED(outs, level, "\"protection\" : ");
			outs << "\"" << std::hex << protection << "\"";
		}

		const virtual bool toJSON(std::stringstream& outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"thread_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		ULONGLONG thread_ip;
		ULONGLONG thread_return;
		DWORD tid;
		DWORD protection;
		DWORD page_state;
	};


	//!  A scanner for threads
	//! Based on the idea presented here: https://github.com/thefLink/Hunt-Sleeping-Beacons
	class ThreadScanner : public ProcessFeatureScanner {
	public:
		// neccessery to validly recognize stack frame
		static bool InitSymbols(HANDLE hProc);
		static bool FreeSymbols(HANDLE hProc);

		ThreadScanner(HANDLE hProc, const util::thread_info& _info, ModulesInfo& _modulesInfo, peconv::ExportsMapper* _exportsMap)
			: ProcessFeatureScanner(hProc), 
			info(_info), modulesInfo(_modulesInfo), exportsMap(_exportsMap)
		{
		}

		virtual ThreadScanReport* scanRemote();

	protected:

		typedef struct _thread_ctx {
			bool is64b;
			ULONGLONG rip;
			ULONGLONG rsp;
			ULONGLONG rbp;
			ULONGLONG ret_addr;
		} thread_ctx;

		bool isAddrInShellcode(ULONGLONG addr);
		bool resolveAddr(ULONGLONG addr);
		bool fetchThreadCtx(IN HANDLE hProcess, IN HANDLE hThread, OUT thread_ctx& c);
		size_t enumStackFrames(IN HANDLE hProcess, IN HANDLE hThread, IN LPVOID ctx, IN OUT thread_ctx& c);
		bool reportSuspiciousAddr(ThreadScanReport* my_report, ULONGLONG susp_addr, thread_ctx& c);

		const util::thread_info& info;
		ModulesInfo& modulesInfo;
		peconv::ExportsMapper* exportsMap;
	};

}; //namespace pesieve

